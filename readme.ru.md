# Progress Counter
Progress Counter - это маленький класс-помошник для подсчета прогресса выполнения случайного количества задач.

#### Описание
Допустим, у вас иеется полоска прогресса, отображающая длительную операцию: сопяжение с сетевым сервером, чтение множества данных с диска, загрузку игрового уровня в масштабной игре; и возникает вопрос: каким образом можно плавно отразить процес выполнения этой длительной операци. Вдобавок все осложняется тем, что количество подзадач всегда разное, да и их трудоемкость тоже от раза к разу меняется. Мало того, что надо отображать процесс выполнения самих задач, так еще и хотелось бы получить отклик от подзадач.

*"Вот бы была такая простя штуковина, на подобии `std::shared_ptr`, которую можно было бы закинуть в задачу балластом, а когда задача выполнится и самоликвидируется, удаление этой самой простой штуковины оповестило бы меня о изменении прогресса!"*

Именно таким образом работает `ProgressCounter`! Объект этого типа (или просто *счетчик*) порождает *цели* (объекты типа `ProgressGoal`). *Цель* фактом своего уничтожения изменяет *счетчик* прогресса. *Целей* может быть любое количество и создавать их тоже можно в любое время используя как сам *счетчик*, так и любую уже созданную *цель*.

#### Потокобезопасность
Вся работа построена на типе `std::shared_ptr` и является (по заверениям стандарта) потокобезопасной. Дополнительно, ряд операций со счетчиком огорожен критической секцией. Это позволяет говорить что вся работа со счетчиком потокобезопасна.

#### Примеры использования
В папке "/tests/test-concurrency/" лежит тест асинхронной работы со счетчиком.

Минимальный набор телодвижений - это создание счетчика:

```.cpp
auto counter = ps::ProgressCounter::Create();
```

И последующая аллокация ряда целей:

```.cpp
auto goal = counter->ProduceGoal();
auto goal2 = goal->GetHostCounter()->ProduceGoal();
```

Все, как только цель уничтожается, она рапортует в счетчик об изменении прогресса.

#### Планы на будущее
Конечно же, текущая реализация далека от идеала. Тут используется память кучи, есть необходимость в критической секции, 14 стандарт не на полную используется, моет быть еще что то есть.
Планы на будущее простые:
* Избавиться от `SharedProgressGoal`, сделать *цели* безопасно перемещаемыми;
* Докутить градус использования 14го стандарта до удоетвоитеьлного;
* Задействовать `atomic` типы и избавиться от критической секции.

